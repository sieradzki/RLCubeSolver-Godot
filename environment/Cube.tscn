[gd_scene load_steps=2 format=3 uid="uid://bbou6w41iat2s"]

[sub_resource type="GDScript" id="GDScript_ar26n"]
script/source = "extends Node

var Piece = preload(\"res://Piece.tscn\")
var pieces = []
var pivot = self
@export var size : int = 3

enum FACES { UP, DOWN, RIGHT, LEFT, FRONT, BACK }

func _ready():
	var positions = get_positions(size)
	var instance: Node3D = Piece.instantiate()
	for x in positions:
		for y in positions:
			for z in positions:
				var piece = instance.duplicate()
				piece.position = Vector3(x, y, z)
				pieces.append(piece)
				add_child(piece)
				# Hide unseen faces
				piece.get_child(0).get_child(FACES.UP).visible = y == positions[-1]
				piece.get_child(0).get_child(FACES.DOWN).visible = y == positions[0]
				piece.get_child(0).get_child(FACES.RIGHT).visible = x == positions[-1]
				piece.get_child(0).get_child(FACES.LEFT).visible = x == positions[0]
				piece.get_child(0).get_child(FACES.FRONT).visible = z == positions[0]
				piece.get_child(0).get_child(FACES.BACK).visible = z == positions[-1]
	get_cube_state_signature()

func get_positions(size):
	# This makes sure the cube is centered on the scene
	if size % 2 == 0:
		# If the number is even, the positive side will have +1 pieces
		return Array(range((-size / 2)+1, size / 2 + 1))
	else:
		return Array(range(-(size / 2), size / 2 + 1))
		
func get_cube_state_signature():
	var sum = Vector3.ZERO
	for cube in get_children():
		sum = cube.rotation + sum
	print(sum.length_squared())

func rotate_face(face_index, depth, dir = 1):
	# Set the correct pivot position for rotation
	pivot = get_pivot_position(face_index, depth)
	var group = get_group(face_index, depth)
	reparent_to_pivot(group)
	rotate_group(face_index, dir)
	reparent_to_origin()
	get_cube_state_signature()

func rotate_group(idx, dir):
	var rot_angle = PI / 2 * dir
	match idx:
		0,1:
			pivot.rotate_x(rot_angle)
		2,3:
			pivot.rotate_y(rot_angle)
		4,5:
			pivot.rotate_z(rot_angle)

func get_pivot_position(face, depth):
	var mid = size / 2 # The middle of the cube in local coordinates
	var pivot_positions = [
		Vector3(mid, 0, 0), Vector3(-mid, 0, 0),  # Right, Left
		Vector3(0, mid, 0), Vector3(0, -mid, 0),  # Up, Down
		Vector3(0, 0, mid), Vector3(0, 0, -mid)   # Front, Back
	]
	return pivot_positions[face]
	
func get_group(face, depth):
	var pivot_pos = [Vector3(-1,0,0),Vector3(1,0,0),Vector3(0,-1,0),Vector3(0,1,0),Vector3(0,0,-1),Vector3(0,0,1)]
	var group = []
	for cube in get_children():
		if abs(cube.position.dot(pivot_pos[face])) == depth:
			group.append(cube)
	if depth == 1: # If rotating the outer layer, set the pivot to one of the cubes in the group
		pivot = group[0]
	return group
	
func is_approx_equal(value1: float, value2: float, epsilon: float = 0.00001) -> bool:
	return abs(value1 - value2) < epsilon

func reparent_to_pivot(group):
	var node = pivot.get_node(\"Body\").get_node(\"Cubes\")
	for cube in group:
		if cube != pivot:
			cube.reparent(node)


func reparent_to_origin():
	if pivot != self:
		for cube in pivot.get_node(\"Body\").get_node(\"Cubes\").get_children():
			cube.reparent(self)
"

[node name="Cube" type="Node3D"]
script = SubResource("GDScript_ar26n")
